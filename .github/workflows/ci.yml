name: CI - Build AL Extension

on:
  push:
    branches: [main, develop]
    paths:
      - 'src/**'
      - 'app.json'
      - '.github/workflows/ci.yml'
  pull_request:
    branches: [main]
    paths:
      - 'src/**'
      - 'app.json'
  workflow_dispatch:

permissions:
  contents: read
  actions: read

defaults:
  run:
    shell: powershell

env:
  BC_ENVIRONMENT: DEVRB

jobs:
  build:
    name: Build AL Extension
    runs-on: windows-latest
    outputs:
      app-name: ${{ steps.app-info.outputs.APP_NAME }}
      app-version: ${{ steps.app-info.outputs.APP_VERSION }}
      artifact-name: ${{ steps.app-info.outputs.ARTIFACT_NAME }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Read app.json
        id: app-info
        run: |
          $appJson = Get-Content -Path "app.json" -Raw | ConvertFrom-Json
          $artifactName = "$($appJson.name)_$($appJson.version)_${{ github.run_number }}"
          echo "APP_NAME=$($appJson.name)" >> $env:GITHUB_OUTPUT
          echo "APP_VERSION=$($appJson.version)" >> $env:GITHUB_OUTPUT
          echo "APP_PUBLISHER=$($appJson.publisher)" >> $env:GITHUB_OUTPUT
          echo "BC_VERSION=$($appJson.application)" >> $env:GITHUB_OUTPUT
          echo "ARTIFACT_NAME=$artifactName" >> $env:GITHUB_OUTPUT

      - name: Validate AL Object IDs
        run: |
          $errors = @()
          $alFiles = Get-ChildItem -Path "src" -Filter "*.al" -Recurse

          foreach ($file in $alFiles) {
              $content = Get-Content $file.FullName -Raw

              # Check table IDs
              if ($content -match "(?m)^table\s+(\d+)") {
                  $id = [int]$matches[1]
                  if ($id -lt 50100 -or $id -gt 50199) {
                      $errors += "Table ID $id in $($file.Name) outside range 50100-50199"
                  }
              }

              # Check page IDs
              if ($content -match "(?m)^page\s+(\d+)") {
                  $id = [int]$matches[1]
                  if ($id -lt 50100 -or $id -gt 50199) {
                      $errors += "Page ID $id in $($file.Name) outside range 50100-50199"
                  }
              }

              # Check codeunit IDs
              if ($content -match "(?m)^codeunit\s+(\d+)") {
                  $id = [int]$matches[1]
                  if ($id -lt 50100 -or $id -gt 50199) {
                      $errors += "Codeunit ID $id in $($file.Name) outside range 50100-50199"
                  }
              }

              # Check enum IDs
              if ($content -match "(?m)^enum\s+(\d+)") {
                  $id = [int]$matches[1]
                  if ($id -lt 50100 -or $id -gt 50199) {
                      $errors += "Enum ID $id in $($file.Name) outside range 50100-50199"
                  }
              }
          }

          if ($errors.Count -gt 0) {
              Write-Host "::error::Object ID validation failed"
              $errors | ForEach-Object { Write-Host "::error::$_" }
              exit 1
          }

          Write-Host "Validated $($alFiles.Count) AL files - all IDs within range 50100-50199"

      - name: Install BcContainerHelper
        run: |
          Install-Module BcContainerHelper -Force -AllowClobber
          Import-Module BcContainerHelper
          Write-Host "BcContainerHelper version: $((Get-Module BcContainerHelper).Version)"

      - name: Compile AL Extension
        run: |
          Import-Module BcContainerHelper

          # Get BC artifact URL
          $artifactUrl = Get-BcArtifactUrl -type Sandbox -country us -select Latest
          Write-Host "Using BC artifact: $artifactUrl"

          # Create compiler folder (includes alc.exe AND symbols)
          $compilerFolder = New-BcCompilerFolder -artifactUrl $artifactUrl -cacheFolder (Join-Path $env:TEMP "cache")
          Write-Host "Compiler folder: $compilerFolder"

          # List compiler folder contents
          Write-Host "Compiler folder contents:"
          Get-ChildItem $compilerFolder | ForEach-Object { Write-Host "  $($_.Name)" }

          # Find alc.exe
          $alcPath = Join-Path $compilerFolder "alc.exe"
          if (-not (Test-Path $alcPath)) {
              $alcFile = Get-ChildItem -Path $compilerFolder -Recurse -Filter "alc.exe" | Select-Object -First 1
              if ($alcFile) {
                  $alcPath = $alcFile.FullName
              } else {
                  Write-Host "::error::Could not find alc.exe"
                  exit 1
              }
          }
          Write-Host "Found AL compiler: $alcPath"

          # The compiler folder should contain symbols - use it as package cache
          # Also check for .app files in the folder
          $symbolsInCompiler = Get-ChildItem -Path $compilerFolder -Filter "*.app" -Recurse
          Write-Host "Symbol files in compiler folder: $($symbolsInCompiler.Count)"
          $symbolsInCompiler | ForEach-Object { Write-Host "  $($_.Name)" }

          # Create output folder
          $outputFolder = "output"
          New-Item -ItemType Directory -Path $outputFolder -Force | Out-Null

          # Get app info
          $appJson = Get-Content -Path "app.json" -Raw | ConvertFrom-Json
          $appFileName = "$($appJson.publisher)_$($appJson.name)_$($appJson.version).app"

          # Compile using the compiler folder as the package cache
          Write-Host "Compiling AL extension..."
          Write-Host "alc.exe /project:$PWD /packagecachepath:$compilerFolder /out:$outputFolder\$appFileName"

          & $alcPath /project:"$PWD" /packagecachepath:"$compilerFolder" /out:"$outputFolder\$appFileName"

          if ($LASTEXITCODE -ne 0) {
              Write-Host "::error::Compilation failed with exit code $LASTEXITCODE"
              exit $LASTEXITCODE
          }

          Write-Host "Compilation successful!"
          Get-ChildItem $outputFolder

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.app-info.outputs.ARTIFACT_NAME }}
          path: output/
          retention-days: 30
          if-no-files-found: error

      - name: Build Summary
        run: |
          Write-Host "================================================"
          Write-Host "Build Complete"
          Write-Host "================================================"
          Write-Host "App: ${{ steps.app-info.outputs.APP_NAME }}"
          Write-Host "Version: ${{ steps.app-info.outputs.APP_VERSION }}"
          Write-Host "Publisher: ${{ steps.app-info.outputs.APP_PUBLISHER }}"
          Write-Host "BC Target: ${{ steps.app-info.outputs.BC_VERSION }}"
          Write-Host "Artifact: ${{ steps.app-info.outputs.ARTIFACT_NAME }}"
          Write-Host "================================================"

  test:
    name: Run AL Tests
    runs-on: windows-latest
    needs: build

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for Test Codeunits
        id: check-tests
        run: |
          $testFiles = Get-ChildItem -Path "src" -Filter "*.al" -Recurse |
            Where-Object { (Get-Content $_.FullName -Raw) -match "Subtype\s*=\s*Test" }

          if ($testFiles.Count -eq 0) {
              Write-Host "No test codeunits found (Subtype = Test). Skipping test execution."
              echo "HAS_TESTS=false" >> $env:GITHUB_OUTPUT
          } else {
              Write-Host "Found $($testFiles.Count) test codeunit(s):"
              $testFiles | ForEach-Object { Write-Host "  - $($_.Name)" }
              echo "HAS_TESTS=true" >> $env:GITHUB_OUTPUT
          }

      - name: Test Summary
        run: |
          Write-Host "================================================"
          Write-Host "Test Check Complete"
          Write-Host "================================================"
          Write-Host "Note: Automated test execution requires deploying"
          Write-Host "to a BC environment. Tests can be run manually"
          Write-Host "using the AL Test Runner in VS Code."
          Write-Host "================================================"
