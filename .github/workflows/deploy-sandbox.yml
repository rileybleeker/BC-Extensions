name: Deploy to Sandbox

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'app.json'
      - '.github/workflows/deploy-sandbox.yml'
  workflow_dispatch:

permissions:
  contents: read
  actions: read

defaults:
  run:
    shell: powershell

env:
  BC_ENVIRONMENT: DEVRB

jobs:
  build-and-deploy:
    name: Build and Deploy to Sandbox
    runs-on: windows-latest
    environment:
      name: sandbox-devrb

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Read app.json
        id: app-info
        run: |
          $appJson = Get-Content -Path "app.json" -Raw | ConvertFrom-Json
          echo "APP_NAME=$($appJson.name)" >> $env:GITHUB_OUTPUT
          echo "APP_VERSION=$($appJson.version)" >> $env:GITHUB_OUTPUT
          echo "APP_PUBLISHER=$($appJson.publisher)" >> $env:GITHUB_OUTPUT

      - name: Install BcContainerHelper
        run: |
          Install-Module BcContainerHelper -Force -AllowClobber
          Import-Module BcContainerHelper
          Write-Host "BcContainerHelper version: $((Get-Module BcContainerHelper).Version)"

      - name: Build Extension
        id: build
        run: |
          Import-Module BcContainerHelper

          # Use absolute paths throughout
          $workDir = $PWD.Path
          $outputDir = Join-Path $workDir ".output"
          Write-Host "Working directory: $workDir"
          Write-Host "Output directory: $outputDir"

          # Get BC artifact URL
          $artifactUrl = Get-BcArtifactUrl -type Sandbox -country us -select Latest
          Write-Host "Using BC artifact: $artifactUrl"

          # Create compiler folder
          $compilerFolder = New-BcCompilerFolder -artifactUrl $artifactUrl -cacheFolder (Join-Path $env:TEMP "cache")
          Write-Host "Compiler folder: $compilerFolder"

          # Find alc.exe
          $alcPath = Join-Path $compilerFolder "alc.exe"
          if (-not (Test-Path $alcPath)) {
              $alcFile = Get-ChildItem -Path $compilerFolder -Recurse -Filter "alc.exe" | Select-Object -First 1
              if ($alcFile) {
                  $alcPath = $alcFile.FullName
              } else {
                  Write-Host "::error::Could not find alc.exe"
                  exit 1
              }
          }

          Write-Host "Found AL compiler: $alcPath"

          # Create output folder with absolute path
          New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
          Write-Host "Created output directory: $(Test-Path $outputDir)"

          # Get app info and compile
          $appJson = Get-Content -Path "app.json" -Raw | ConvertFrom-Json
          $appFileName = "$($appJson.publisher)_$($appJson.name)_$($appJson.version).app"
          $appFullPath = Join-Path $outputDir $appFileName

          Write-Host "Compiling to: $appFullPath"
          & $alcPath /project:"$workDir" /packagecachepath:"$compilerFolder" /out:"$appFullPath"

          $exitCode = $LASTEXITCODE
          Write-Host "Compiler exit code: $exitCode"

          if ($exitCode -ne 0) {
              Write-Host "::error::Compilation failed with exit code $exitCode"
              exit $exitCode
          }

          # Verify the file exists
          if (Test-Path $appFullPath) {
              $fileSize = (Get-Item $appFullPath).Length
              Write-Host "SUCCESS: $appFullPath exists ($fileSize bytes)"

              # Output for next steps
              echo "APP_FILE=$appFullPath" >> $env:GITHUB_OUTPUT
              echo "OUTPUT_DIR=$outputDir" >> $env:GITHUB_OUTPUT

              # List directory contents
              Write-Host "Output directory contents:"
              Get-ChildItem $outputDir
          } else {
              Write-Host "::error::App file not found at $appFullPath"
              Write-Host "Searching for .app files anywhere:"
              Get-ChildItem $workDir -Recurse -Filter "*.app" | ForEach-Object { Write-Host "Found: $($_.FullName)" }
              exit 1
          }

      - name: Deploy to BC Sandbox
        env:
          AUTH_CONTEXT: ${{ secrets.BC_AUTH_CONTEXT }}
          APP_FILE: ${{ steps.build.outputs.APP_FILE }}
        run: |
          Import-Module BcContainerHelper

          # Use the app file path from build step
          $appFilePath = $env:APP_FILE
          Write-Host "Using app file from build step: $appFilePath"

          if (-not (Test-Path $appFilePath)) {
              Write-Host "::error::App file not found at $appFilePath"
              exit 1
          }

          # Parse the stored credentials
          $creds = $env:AUTH_CONTEXT | ConvertFrom-Json

          # Create proper auth context using New-BcAuthContext
          $authContext = New-BcAuthContext `
              -tenantID $creds.tenantId `
              -clientID $creds.clientId `
              -clientSecret (ConvertTo-SecureString -String $creds.clientSecret -AsPlainText -Force)

          Write-Host "Deploying to ${{ env.BC_ENVIRONMENT }}..."
          Write-Host "Tenant ID: $($creds.tenantId)"

          try {
              # Publish to BC Online using Publish-PerTenantExtensionApps for SaaS
              Publish-PerTenantExtensionApps `
                  -bcAuthContext $authContext `
                  -environment "${{ env.BC_ENVIRONMENT }}" `
                  -appFiles @($appFilePath) `
                  -schemaSyncMode Force

              Write-Host "Deployment complete!"
          }
          catch {
              Write-Host "::error::Deployment failed: $_"
              Write-Host "Error details: $($_.Exception.Message)"
              if ($_.Exception.Response) {
                  $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                  $responseBody = $reader.ReadToEnd()
                  Write-Host "Response body: $responseBody"
              }
              throw
          }

      - name: Debug - List output folder
        if: always()
        env:
          OUTPUT_DIR: ${{ steps.build.outputs.OUTPUT_DIR }}
        run: |
          Write-Host "Current directory: $PWD"
          Write-Host "OUTPUT_DIR env var: $env:OUTPUT_DIR"

          # Check the hardcoded path directly
          $hardcodedPath = "D:\a\BC-Extensions\BC-Extensions\.output"
          Write-Host "Checking hardcoded path: $hardcodedPath"
          if (Test-Path $hardcodedPath) {
              Write-Host "Hardcoded path exists. Contents:"
              Get-ChildItem $hardcodedPath -Recurse
          } else {
              Write-Host "Hardcoded path does NOT exist"
          }

          # Also check relative path
          Write-Host "Checking relative .output path:"
          if (Test-Path ".output") {
              Write-Host "Relative .output exists. Contents:"
              Get-ChildItem ".output" -Recurse
          } else {
              Write-Host "Relative .output does NOT exist"
          }

          # Check if OUTPUT_DIR from step output works
          if ($env:OUTPUT_DIR -and (Test-Path $env:OUTPUT_DIR)) {
              Write-Host "Step output path exists. Contents:"
              Get-ChildItem $env:OUTPUT_DIR -Recurse
          } else {
              Write-Host "Step output path empty or doesn't exist"
          }

      - name: Upload Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-${{ steps.app-info.outputs.APP_VERSION }}-${{ github.run_number }}
          path: .output/
          retention-days: 90
          if-no-files-found: warn

      - name: Deployment Summary
        run: |
          Write-Host "================================================"
          Write-Host "Deployment Complete"
          Write-Host "================================================"
          Write-Host "App: ${{ steps.app-info.outputs.APP_NAME }}"
          Write-Host "Version: ${{ steps.app-info.outputs.APP_VERSION }}"
          Write-Host "Environment: ${{ env.BC_ENVIRONMENT }}"
          Write-Host "================================================"
